#!/usr/bin/env bash
set -euo pipefail


# Colors
C_RESET='\033[0m'
C_OK='\033[0;32m'
C_WARN='\033[1;33m'
C_ERR='\033[0;31m'
C_HEAD='\033[1;36m'

# Helpers
say()  { printf "%b[INFO]%b %s\n" "$C_HEAD" "$C_RESET" "$*"; }
ok()   { printf "%b[OK]%b %s\n" "$C_OK"   "$C_RESET" "$*"; }
warn() { printf "%b[WARN]%b %s\n" "$C_WARN" "$C_RESET" "$*"; }
err()  { printf "%b[ERR]%b %s\n" "$C_ERR"  "$C_RESET" "$*" >&2; }

# Check for sudo/root
if [[ $EUID -ne 0 ]] && ! command -v sudo >/dev/null 2>&1; then
    err "This script requires sudo rights to install packages."
    exit 1
fi

# Clipboard Helper
copy_to_clip() {
    local input_file="$1"
    local clip_cmd=""

    if [[ "$XDG_SESSION_TYPE" == "wayland" ]] && command -v wl-copy >/dev/null 2>&1; then
        clip_cmd="wl-copy"
    elif command -v xclip >/dev/null 2>&1; then
        clip_cmd="xclip -selection clipboard"
    fi

    if [[ -n "$clip_cmd" ]]; then
        cat "$input_file" | $clip_cmd
        ok "Content of $(basename "$input_file") copied to clipboard."
    else
        warn "No clipboard utility found (wl-copy or xclip). Skipping copy."
    fi
}

ensure_packages() {
    say "Checking system dependencies..."
    local deps=(openssh-clients gnupg2 pinentry git)

    # Detect clipboard tool needed
    if [[ "${XDG_SESSION_TYPE:-}" == "wayland" ]]; then
        deps+=(wl-clipboard)
    else
        deps+=(xclip)
    fi

    # Install missing only
    local to_install=()
    for pkg in "${deps[@]}"; do
        if ! rpm -q "$pkg" &>/dev/null; then
            to_install+=("$pkg")
        fi
    done

    if [[ ${#to_install[@]} -gt 0 ]]; then
        say "Installing: ${to_install[*]}"
        sudo dnf install -y "${to_install[@]}"
        ok "Dependencies installed."
    else
        ok "All dependencies already installed."
    fi
}

setup_ssh() {
    say "Starting SSH Setup..."

    local keyfile="$HOME/.ssh/id_ed25519"

    if [[ -f "$keyfile" ]]; then
        warn "SSH key already exists ($keyfile). Skipping generation."
    else
        read -rp "Enter email for SSH key comment: " email
        email=${email:-"$(whoami)@$(hostname)"}
        ssh-keygen -t ed25519 -C "$email" -f "$keyfile"
        ok "SSH key generated."
    fi

    # Smarter Agent Handling
    if [[ -z "${SSH_AUTH_SOCK:-}" ]]; then
        say "Starting ssh-agent..."
        eval "$(ssh-agent -s)"
    else
        ok "ssh-agent is already running."
    fi

    ssh-add "$keyfile" 2>/dev/null || warn "Key not added (maybe password protected and skipped?)"

    # Add known hosts to prevent first-connect prompt
    mkdir -p "$HOME/.ssh"
    touch "$HOME/.ssh/known_hosts"
    say "Scanning GitHub/GitLab host keys..."
    ssh-keyscan -H github.com gitlab.com 2>/dev/null >> "$HOME/.ssh/known_hosts" || true

    # Remove duplicate lines in known_hosts (clean up)
    sort -u "$HOME/.ssh/known_hosts" -o "$HOME/.ssh/known_hosts"

    echo "------------------------------------------------------------"
    cat "$keyfile.pub"
    echo "------------------------------------------------------------"
    copy_to_clip "$keyfile.pub"
}

setup_gpg() {
    say "Starting GPG Setup..."

    # Check if keys exist to prevent redundant prompts
    if gpg --list-secret-keys --keyid-format LONG | grep -q "sec"; then
        warn "GPG keys already exist. Run '4) Show keys' to see them."
        read -rp "Generate a NEW key anyway? [y/N]: " ans
        if [[ ! "$ans" =~ ^[Yy]$ ]]; then return; fi
    fi

    say "Generating key. Follow the prompts..."
    gpg --full-generate-key

    # Auto-export the most recently generated key
    local latest_key_email
    latest_key_email=$(gpg --list-keys --with-colons | awk -F: '/^uid/ {print $10}' | tail -n1 | sed 's/.*<\(.*\)>/\1/')

    if [[ -n "$latest_key_email" ]]; then
        say "Detected new key for: $latest_key_email"
        read -rp "Export public key to clipboard? [Y/n]: " ans
        if [[ -z "${ans:-}" || "$ans" =~ ^[Yy]$ ]]; then
            gpg --armor --export "$latest_key_email" > "/tmp/gpg_pub.asc"
            copy_to_clip "/tmp/gpg_pub.asc"
            rm "/tmp/gpg_pub.asc"
        fi
    fi
}

setup_git_gpg() {
    say "Configuring Git Global Settings..."

    # Ensure GPG TTY is set in current session and .bashrc
    export GPG_TTY=$(tty)
    if ! grep -qF "export GPG_TTY" "$HOME/.bashrc"; then
        echo 'export GPG_TTY=$(tty)' >> "$HOME/.bashrc"
        ok "Added GPG_TTY to .bashrc"
    else
        ok "GPG_TTY already present in .bashrc"
    fi

    # Attempt to auto-detect key
    local key_count
    key_count=$(gpg --list-secret-keys --keyid-format LONG | grep -c "sec")

    local keyid=""

    if [[ "$key_count" -eq 0 ]]; then
        err "No GPG secret keys found. Please run Setup GPG first."
        return
    elif [[ "$key_count" -eq 1 ]]; then
        # Grab the ID of the only key
        keyid=$(gpg --list-secret-keys --keyid-format LONG | grep "sec" | awk '{print $2}' | cut -d'/' -f2)
        say "Found one GPG key: $keyid"
    else
        # Multiple keys, ask user
        gpg --list-secret-keys --keyid-format LONG
        echo
        read -rp "Multiple keys found. Paste the Key ID (after rsa4096/ or ed25519/): " user_key
        keyid="$user_key"
    fi

    if [[ -n "$keyid" ]]; then
        git config --global user.signingkey "$keyid"
        git config --global commit.gpgsign true
        git config --global gpg.program gpg
        ok "Git configured to sign with key: $keyid"
    else
        err "Invalid Key ID."
    fi
}

delete_ssh() {
    local keyfile="$HOME/.ssh/id_ed25519"
    if [[ ! -f "$keyfile" ]]; then
        warn "No default ed25519 key found."
        return
    fi
    read -rp "DELETE SSH key ($keyfile)? [y/N]: " ans
    if [[ "$ans" =~ ^[Yy]$ ]]; then
        rm -f "$keyfile" "$keyfile.pub"
        ok "SSH key deleted."
    fi
}

delete_gpg() {
    echo
    gpg --list-keys --keyid-format LONG
    echo
    read -rp "Enter Key ID to DELETE (pub & secret): " keyid

    if [[ -z "$keyid" ]]; then warn "Cancelled."; return; fi

    read -rp "Are you SURE? This cannot be undone. [y/N]: " ans
    if [[ "$ans" =~ ^[Yy]$ ]]; then
        # Must delete secret first, then public
        gpg --delete-secret-keys "$keyid" || warn "Failed to delete secret key (or it didn't exist)."
        gpg --delete-keys "$keyid" || warn "Failed to delete public key."
        ok "GPG deletion attempted."
    fi
}

show_keys() {
    echo
    say "--- SSH Public Key ---"
    if [[ -f "$HOME/.ssh/id_ed25519.pub" ]]; then
        cat "$HOME/.ssh/id_ed25519.pub"
    else
        warn "No ed25519 public key found."
    fi

    echo
    say "--- GPG Keys ---"
    gpg --list-secret-keys --keyid-format=short 2>/dev/null || warn "No GPG keys found."

    echo
    say "--- Git Configuration ---"
    echo "Signing Key: $(git config --global user.signingkey || echo 'Not Set')"
    echo "Auto Sign:   $(git config --global commit.gpgsign || echo 'Not Set')"
    echo
    read -rp "Press Enter to continue..."
}

# ============================================================
# Main Logic
# ============================================================

# Pre-flight check
if ! command -v dnf >/dev/null 2>&1; then
    err "This script requires Fedora (dnf)."
    exit 1
fi

while true; do
    echo
    printf "%bFedora SSH+GPG Manager%b\n" "$C_HEAD" "$C_RESET"
    echo "1) Setup SSH"
    echo "2) Setup GPG"
    echo "3) Setup BOTH (Recommended)"
    echo "4) Show Keys & Config"
    echo "5) Link GPG to Git"
    echo "6) Delete SSH Key"
    echo "7) Delete GPG Key"
    echo "0) Exit"

    read -rp "Select option: " opt
    case $opt in
        1) ensure_packages; setup_ssh ;;
        2) ensure_packages; setup_gpg ;;
        3) ensure_packages; setup_ssh; setup_gpg; setup_git_gpg ;;
        4) show_keys ;;
        5) ensure_packages; setup_git_gpg ;;
        6) delete_ssh ;;
        7) delete_gpg ;;
        0) exit 0 ;;
        *) warn "Invalid option." ;;
    esac
done
